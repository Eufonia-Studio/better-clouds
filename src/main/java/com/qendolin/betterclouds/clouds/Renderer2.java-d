package com.qendolin.betterclouds.clouds;

import com.google.common.collect.ImmutableMap;
import com.mojang.blaze3d.platform.GlConst;
import com.mojang.blaze3d.platform.GlStateManager;
import com.mojang.blaze3d.systems.RenderSystem;
import com.qendolin.betterclouds.Config;
import com.qendolin.betterclouds.Main;
import com.qendolin.betterclouds.compat.IrisCompat;
import com.qendolin.betterclouds.compat.SodiumExtraCompat;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.option.CloudRenderMode;
import net.minecraft.client.render.DimensionEffects;
import net.minecraft.client.render.Frustum;
import net.minecraft.client.render.debug.DebugRenderer;
import net.minecraft.client.util.math.MatrixStack;
import net.minecraft.client.world.ClientWorld;
import net.minecraft.resource.ResourceManager;
import net.minecraft.text.Text;
import net.minecraft.util.Identifier;
import net.minecraft.util.Util;
import net.minecraft.util.math.Box;
import net.minecraft.util.math.Matrix4f;
import net.minecraft.util.math.Vec3d;
import org.lwjgl.opengl.*;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import static org.lwjgl.opengl.GL11.*;
import static org.lwjgl.opengl.GL15.*;
import static org.lwjgl.opengl.GL30.*;
import static org.lwjgl.opengl.GL30.glFramebufferTexture2D;

public class Renderer2 implements AutoCloseable {

    private static final Identifier CLOUD_NOISE = new Identifier(Main.MODID, "textures/environment/cloud_noise.png");
    private static final Identifier COLOR_GRADIENT = new Identifier(Main.MODID, "textures/environment/cloud_gradient.png");

    private final MinecraftClient client;
    private ClientWorld world = null;

    private CloudRenderMode lastCloudRenderMode = null;
    private MainShader cloudShader = null;
    private PostShader cloudShader2 = null;
    private ChunkedGenerator cloudGenerator = null;
    private float lastDistance = -1;
    private final long startTime = Util.getEpochTimeMs();
    private int quadVbo;
    private int quadVao;
    private int oitFbo;
    private int oitAccumTexture;
    private int oitRevealTexture;
    private int oitCustomTexture;
    private int fboWidth;
    private int fboHeight;

    private GlTimer timer;

    public Renderer2(MinecraftClient client) {
        this.client = client;
    }

    public void reload(ResourceManager manager) {
        GL44.glEnable(GL44.GL_DEBUG_OUTPUT_SYNCHRONOUS);

        reloadShader(manager);
        reloadGenerator();

        client.getTextureManager().getTexture(CLOUD_NOISE).bindTexture();
        RenderSystem.texParameter(GlConst.GL_TEXTURE_2D, GlConst.GL_TEXTURE_WRAP_S, GL_REPEAT);
        RenderSystem.texParameter(GlConst.GL_TEXTURE_2D, GlConst.GL_TEXTURE_WRAP_T, GL_REPEAT);
        RenderSystem.texParameter(GlConst.GL_TEXTURE_2D, GlConst.GL_TEXTURE_MIN_FILTER, GlConst.GL_LINEAR);
        RenderSystem.texParameter(GlConst.GL_TEXTURE_2D, GlConst.GL_TEXTURE_MAG_FILTER, GlConst.GL_LINEAR);
        client.getTextureManager().getTexture(COLOR_GRADIENT).bindTexture();
        RenderSystem.texParameter(GlConst.GL_TEXTURE_2D, GlConst.GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        RenderSystem.texParameter(GlConst.GL_TEXTURE_2D, GlConst.GL_TEXTURE_WRAP_T, GL_REPEAT);
        RenderSystem.texParameter(GlConst.GL_TEXTURE_2D, GlConst.GL_TEXTURE_MIN_FILTER, GlConst.GL_LINEAR);
        RenderSystem.texParameter(GlConst.GL_TEXTURE_2D, GlConst.GL_TEXTURE_MAG_FILTER, GlConst.GL_LINEAR);

        if(quadVbo != 0) glDeleteBuffers(quadVbo);
        if(quadVao != 0) glDeleteVertexArrays(quadVao);
        quadVao = glGenVertexArrays();
        glBindVertexArray(quadVao);
        if(Main.IS_DEV) GL44.glObjectLabel(GL44.GL_VERTEX_ARRAY, quadVao, "cloud_quad_vao");
        quadVbo = glGenBuffers();
        glBindBuffer(GL_ARRAY_BUFFER, quadVbo);
        if(Main.IS_DEV) GL44.glObjectLabel(GL44.GL_BUFFER, quadVbo, "cloud_quad_vbo");
        glBufferData(GL_ARRAY_BUFFER, new float[]{1,-1, 1,1, -1,-1, -1,1}, GL_STATIC_DRAW);
        glEnableVertexAttribArray(0);
        glVertexAttribPointer(0, 2, GL_FLOAT, false, 0, 0);

        reloadFramebufferCustom();

        if(timer != null) timer.close();
        timer = new GlTimer();
    }

    public void setWorld(ClientWorld world) {
        this.world = world;
    }

    private void reloadGenerator() {
        if(cloudGenerator != null) cloudGenerator.close();
        cloudGenerator = new ChunkedGenerator();
        cloudGenerator.allocate(Main.CONFIG, isFancyMode());
        cloudGenerator.clear();
    }

    private void reloadFramebufferMS() {
        if(oitFbo != 0) glDeleteFramebuffers(oitFbo);
        oitFbo = glGenFramebuffers();
        glBindFramebuffer(GL_DRAW_FRAMEBUFFER, oitFbo);
        if(Main.IS_DEV) GL44.glObjectLabel(GL_FRAMEBUFFER, oitFbo, "cloud_oit_framebuffer");

        fboWidth = client.getFramebuffer().textureWidth/2;
        fboHeight = client.getFramebuffer().textureHeight/2;

        if(oitAccumTexture != 0) glDeleteTextures(oitAccumTexture);
        oitAccumTexture = glGenTextures();
        glBindTexture(GL44.GL_TEXTURE_2D_MULTISAMPLE, oitAccumTexture);
        if(Main.IS_DEV) GL44.glObjectLabel(GL_TEXTURE, oitAccumTexture, "cloud_oit_accumulate");
        GL44.glTexImage2DMultisample(GL44.GL_TEXTURE_2D_MULTISAMPLE, 2, GL_RGBA16F, fboWidth, fboHeight, false);
        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL44.GL_TEXTURE_2D_MULTISAMPLE, oitAccumTexture, 0);

        if(oitRevealTexture != 0) glDeleteTextures(oitRevealTexture);
        oitRevealTexture = glGenTextures();
        glBindTexture(GL44.GL_TEXTURE_2D_MULTISAMPLE, oitRevealTexture);
        if(Main.IS_DEV) GL44.glObjectLabel(GL_TEXTURE, oitRevealTexture, "cloud_oit_reveal");
        GL44.glTexImage2DMultisample(GL44.GL_TEXTURE_2D_MULTISAMPLE, 2, GL_R8, fboWidth, fboHeight, false);
        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL44.GL_TEXTURE_2D_MULTISAMPLE, oitRevealTexture, 0);

        glDrawBuffers(new int[]{GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1});

        int status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
        if (status != GL_FRAMEBUFFER_COMPLETE) {
            throw new RuntimeException("Clouds framebuffer incomplete, status: " + status);
        }
    }

    private void reloadFramebuffer() {
        if(oitFbo != 0) glDeleteFramebuffers(oitFbo);
        oitFbo = glGenFramebuffers();
        glBindFramebuffer(GL_DRAW_FRAMEBUFFER, oitFbo);
        if(Main.IS_DEV) GL44.glObjectLabel(GL_FRAMEBUFFER, oitFbo, "cloud_oit_framebuffer");

        fboWidth = client.getFramebuffer().textureWidth;
        fboHeight = client.getFramebuffer().textureHeight;

        if(oitAccumTexture != 0) glDeleteTextures(oitAccumTexture);
        oitAccumTexture = glGenTextures();
        glBindTexture(GL_TEXTURE_2D, oitAccumTexture);
        if(Main.IS_DEV) GL44.glObjectLabel(GL_TEXTURE, oitAccumTexture, "cloud_oit_accumulate");
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F, fboWidth, fboHeight, 0, GL_RGBA, GL_HALF_FLOAT, 0);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, oitAccumTexture, 0);

        if(oitRevealTexture != 0) glDeleteTextures(oitRevealTexture);
        oitRevealTexture = glGenTextures();
        glBindTexture(GL_TEXTURE_2D, oitRevealTexture);
        if(Main.IS_DEV) GL44.glObjectLabel(GL_TEXTURE, oitRevealTexture, "cloud_oit_reveal");
        glTexImage2D(GL_TEXTURE_2D, 0, GL_R8, fboWidth, fboHeight, 0, GL_RED, GL_FLOAT, 0);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D, oitRevealTexture, 0);

        glDrawBuffers(new int[]{GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1});

        // FIXME: not sure if I need to bid the texture, probably not
        GlStateManager._bindTexture(client.getFramebuffer().getDepthAttachment());
        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, client.getFramebuffer().getDepthAttachment(), 0);

        int status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
        if (status != GL_FRAMEBUFFER_COMPLETE) {
            throw new RuntimeException("Clouds framebuffer incomplete, status: " + status);
        }
    }

    private void reloadFramebufferCustom() {
        if(oitFbo != 0) glDeleteFramebuffers(oitFbo);
        oitFbo = glGenFramebuffers();
        glBindFramebuffer(GL_DRAW_FRAMEBUFFER, oitFbo);
        if(Main.IS_DEV) GL44.glObjectLabel(GL_FRAMEBUFFER, oitFbo, "cloud_oit_framebuffer");

        fboWidth = client.getFramebuffer().textureWidth;
        fboHeight = client.getFramebuffer().textureHeight;

        if(oitCustomTexture != 0) glDeleteTextures(oitCustomTexture);
        oitCustomTexture = glGenTextures();
        glBindTexture(GL_TEXTURE_2D, oitCustomTexture);
        if(Main.IS_DEV) GL44.glObjectLabel(GL_TEXTURE, oitCustomTexture, "cloud_oit_custom");
        glTexImage2D(GL_TEXTURE_2D, 0, GL_R8UI, fboWidth, fboHeight, 0, GL_RED, GL_UNSIGNED_BYTE, 0);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, oitCustomTexture, 0);

        glDrawBuffers(new int[]{GL_COLOR_ATTACHMENT0});

        // FIXME: not sure if I need to bid the texture, probably not
        GlStateManager._bindTexture(client.getFramebuffer().getDepthAttachment());
        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, client.getFramebuffer().getDepthAttachment(), 0);

        int status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
        if (status != GL_FRAMEBUFFER_COMPLETE) {
            throw new RuntimeException("Clouds framebuffer incomplete, status: " + status);
        }
    }

    private void reloadShader(ResourceManager manager) {
        if(cloudShader != null) cloudShader.close();
        Config options = Main.CONFIG;
        Map<String, String> defs = ImmutableMap.ofEntries(
            Map.entry(MainShader.DEF_SIZE_X_KEY, Float.toString(options.sizeXZ)),
            Map.entry(MainShader.DEF_SIZE_Y_KEY, Float.toString(options.sizeY)),
            Map.entry(MainShader.DEF_FADE_EDGE_KEY, Integer.toString(options.fadeEdge)),
            Map.entry(MainShader.DEF_GRADIENT_COLOR_KEY, options.gradientColoring ? "1" : "0")
        );

        try {
            cloudShader = new MainShader(manager, options.enableExperimentalIrisSupport, isFancyMode(), defs);
            cloudShader.bind();
            cloudShader.uCloudNoise.setInt(0);
            cloudShader.uGradient.setInt(1);
            cloudShader.uDepth.setInt(2);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        try {
            cloudShader2 = new PostShader(manager, Map.of());
            cloudShader2.bind();
            cloudShader2.uAccum.setInt(0);
            cloudShader2.uReveal.setInt(1);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public boolean skipRender() {
        boolean disabledForIris = !Main.CONFIG.enableExperimentalIrisSupport && IrisCompat.IS_LOADED && IrisCompat.isShadersEnabled();
        return disabledForIris;
    }

    public void render(MatrixStack matrices, Matrix4f projMat, float tickDelta, int ticks, Vec3d cam, Frustum frustum) {
        assert RenderSystem.isOnRenderThread();
        client.getProfiler().push("render_setup");

        // When the shader could not be loaded
        if (cloudShader == null || !cloudShader.isComplete()) return;
        if(Main.IS_DEV) GL43.glPushDebugGroup(GL43.GL_DEBUG_SOURCE_APPLICATION, 1337, "Better Clouds\0");

        timer.start();

        matrices.push();
        matrices.translate(0, -cam.y, 0);
        DimensionEffects effects = world.getDimensionEffects();

        if(Main.CONFIG.hasChanged || lastCloudRenderMode != client.options.getCloudRenderModeValue() || lastDistance != Main.CONFIG.blockDistance()) {
            lastDistance = Main.CONFIG.blockDistance();
            lastCloudRenderMode = client.options.getCloudRenderModeValue();
            reloadShader(client.getResourceManager());
            cloudGenerator.reallocate(Main.CONFIG, isFancyMode());
            Main.CONFIG.hasChanged = false;
        }

        float raininess = Math.max(0.6f*world.getRainGradient(tickDelta), world.getThunderGradient(tickDelta));
        float cloudiness = raininess * 0.3f + 0.5f;

        cloudGenerator.bind();
        cloudGenerator.update(cam, tickDelta, Main.CONFIG, cloudiness);
        if(cloudGenerator.canGenerate() && !cloudGenerator.generating()) {
            client.getProfiler().swap("generate_clouds");
            cloudGenerator.generate();
            client.getProfiler().swap("render_setup");
        }
        if(cloudGenerator.canSwap()) {
            client.getProfiler().swap("swap");
            cloudGenerator.swap();
            client.getProfiler().swap("render_setup");
        }

        float cloudsHeight = getCloudsHeight(effects);
        matrices.translate(cloudGenerator.renderOriginX(cam.x), cloudsHeight, cloudGenerator.renderOriginZ(cam.z));
        /// TODO: remove
//        if(Main.CONFIG.sort) {
//            client.getProfiler().swap("sort");
//            cloudGenerator.sort((float) cloudGenerator.renderOriginX(cam.x), (float) (cloudsHeight-cam.y), (float) cloudGenerator.renderOriginZ(cam.z));
//            client.getProfiler().swap("render_setup");
//        }

        Matrix4f mvpMat = projMat.copy();
        mvpMat.multiply(matrices.peek().getPositionMatrix());
        cloudShader.bind();
        cloudShader.uModelViewProjMat.setMat4(mvpMat);
        cloudShader.uCloudsOrigin.setVec3((float) -cloudGenerator.renderOriginX(cam.x), (float)cam.y-cloudsHeight, (float) -cloudGenerator.renderOriginZ(cam.z));
        cloudShader.uCloudsDistance.setFloat(Main.CONFIG.blockDistance() - Main.CONFIG.chunkSize/2f);
        cloudShader.uCloudsBox.setVec4((float) cam.x, (float) cam.z, (float) cam.y-cloudsHeight, Main.CONFIG.spreadY);

        float skyAngle = world.getSkyAngleRadians(tickDelta);
        cloudShader.uSkyData.setVec4((float) -Math.sin(skyAngle), (float) Math.cos(skyAngle), world.getTimeOfDay()/24000f, 1-0.75f*raininess);

        Vec3d skyColor = new Vec3d(Main.CONFIG.red, Main.CONFIG.green, Main.CONFIG.blue); // world.getCloudsColor(tickDelta);
        cloudShader.uSkyColor.setVec4((float) skyColor.x, (float) skyColor.y, (float) skyColor.z, Main.CONFIG.opacity);

        float[] skyColorOverride = effects.getFogColorOverride(world.getSkyAngle(tickDelta), tickDelta);
        if (skyColorOverride != null) {
            cloudShader.uSkyColorOverride.setVec4(skyColorOverride[0], skyColorOverride[1], skyColorOverride[2], skyColorOverride[3]);
        } else {
            cloudShader.uSkyColorOverride.setVec4(0, 0, 0, 0);
        }
        cloudShader.uGradientPos.setFloat(Main.CONFIG.gradientPos);

        RenderSystem.enableBlend();
//        RenderSystem.blendFuncSeparate(GlStateManager.SrcFactor.SRC_ALPHA, GlStateManager.DstFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SrcFactor.ONE_MINUS_DST_ALPHA, GlStateManager.DstFactor.ONE);
        // TODO: remove option
        if(!Main.CONFIG.writeDepth) {
            RenderSystem.depthMask(false);
        }
        RenderSystem.depthFunc(Main.CONFIG.depthTest ? GL_LEQUAL : GL_ALWAYS);

        // Fix for https://github.com/Qendolin/better-clouds/issues/4
        RenderSystem.enableDepthTest();
        if (!isFancyMode()) {
            RenderSystem.disableCull();
        }

//        RenderSystem.blendEquation(GL_FUNC_ADD);
//        if(GL.getCapabilities().OpenGL44) {
//            GL44.glBlendFunci(0, GL_ONE, GL_ONE);
//            GL44.glBlendFunci(1, GL_ZERO, GL_ONE_MINUS_SRC_COLOR);
//        } else {
//            ARBDrawBuffersBlend.glBlendFunciARB(0, GL_ONE, GL_ONE);
//            ARBDrawBuffersBlend.glBlendFunciARB(1, GL_ZERO, GL_ONE_MINUS_SRC_COLOR);
//        }

        RenderSystem.blendEquation(GL_FUNC_ADD);
        RenderSystem.blendFunc(GlStateManager.SrcFactor.ONE, GlStateManager.DstFactor.ONE);

        int lastBoundFbo = glGetInteger(GL_DRAW_FRAMEBUFFER_BINDING);
        glBindFramebuffer(GL_DRAW_FRAMEBUFFER, oitFbo);
        RenderSystem.viewport(0, 0, fboWidth, fboHeight);
        glClearBufferfv(GL_COLOR, 0, new float[] {0, 0, 0, 0});
//        glClearBufferfv(GL_COLOR, 1, new float[] {1, 1, 1, 1});

        client.getProfiler().swap("draw_geometry");

        cloudShader.uColor.setVec4(Main.CONFIG.red, Main.CONFIG.green, Main.CONFIG.blue, 1.0f);
        cloudShader.uTime.setFloat((Util.getEpochTimeMs() - startTime)/1000f);
        RenderSystem.enableTexture();
        RenderSystem.activeTexture(GlConst.GL_TEXTURE0);
        client.getTextureManager().getTexture(CLOUD_NOISE).bindTexture();
        RenderSystem.activeTexture(GlConst.GL_TEXTURE1);
        client.getTextureManager().getTexture(COLOR_GRADIENT).bindTexture();
        RenderSystem.activeTexture(GlConst.GL_TEXTURE2);
        RenderSystem.bindTexture(client.getFramebuffer().getDepthAttachment());

//        List<Box> visibleChunks = new ArrayList<>();
//        List<Box> hiddenChunks = new ArrayList<>();

        if(cloudGenerator.canRender()) {
//            GL44.glDrawArraysInstanced(GL_TRIANGLE_STRIP, 0, cloudGenerator.instanceVertexCount(), cloudGenerator.cloudCount());

            // TODO: improve grouping
            int runStart = -1;
            int runCount = 0;
            for (ChunkedGenerator.ChunkIndex chunk : cloudGenerator.chunks()) {
                // FIXME: memory alloc
                Box bounds = chunk.bounds(cloudsHeight, Main.CONFIG.sizeXZ, Main.CONFIG.sizeY);
                if(!frustum.isVisible(bounds)) {
                    if(runCount != 0) {
                        GL44.glDrawArraysInstancedBaseInstance(GL_TRIANGLE_STRIP, 0, cloudGenerator.instanceVertexCount(), runCount, runStart);
                    }
                    runStart = -1;
                    runCount = 0;
//                    hiddenChunks.add(bounds);
                } else {
                    if(runStart == -1) runStart = chunk.start();
                    runCount += chunk.count();
//                    visibleChunks.add(bounds);
                }
            }
            if(runCount != 0) {
                GL44.glDrawArraysInstancedBaseInstance(GL_TRIANGLE_STRIP, 0, cloudGenerator.instanceVertexCount(), runCount, runStart);
            }
        }

        client.getProfiler().swap("draw_shading");

        RenderSystem.disableDepthTest();
        RenderSystem.depthMask(false);

        GlStateManager._glBindFramebuffer(GL_DRAW_FRAMEBUFFER, lastBoundFbo);
        // TODO: viewport might not be correct always
        RenderSystem.viewport(0, 0, client.getFramebuffer().textureWidth, client.getFramebuffer().textureHeight);
        RenderSystem.activeTexture(GL_TEXTURE0);
        // FIXME: don't bind to 0 just because GL_TEXTURE_2D_MULTISAMPLE
//        GlStateManager._bindTexture(0);
        glBindTexture(GL44.GL_TEXTURE_2D, oitAccumTexture);
        RenderSystem.activeTexture(GL_TEXTURE1);
//        GlStateManager._bindTexture(0);
        glBindTexture(GL44.GL_TEXTURE_2D, oitRevealTexture);
        // FIXME: I don't know which blend func is correct
//        RenderSystem.blendFunc(GlStateManager.SrcFactor.SRC_ALPHA, GlStateManager.DstFactor.ONE_MINUS_SRC_ALPHA);
//        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        RenderSystem.blendFuncSeparate(GlStateManager.SrcFactor.SRC_ALPHA, GlStateManager.DstFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SrcFactor.ZERO, GlStateManager.DstFactor.ONE);


        if(IrisCompat.IS_LOADED && IrisCompat.isShadersEnabled() && Main.CONFIG.useIrisFBO) IrisCompat.bindFramebuffer();

        cloudShader2.bind();
        cloudShader2.uGamma.setVec3(Main.CONFIG.brightness, Main.CONFIG.gamma, Main.CONFIG.alphaFactor);
        glBindVertexArray(quadVao);
        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);

        client.getProfiler().swap("render_cleanup");

        RenderSystem.enableDepthTest();

        RenderSystem.depthMask(true);
        RenderSystem.depthFunc(GL_LESS);
        RenderSystem.disableBlend();
        if (!isFancyMode()) {
            RenderSystem.enableCull();
        }
        Shader.unbind();
        cloudGenerator.unbind();

        matrices.pop();
        client.getProfiler().pop();

        timer.stop();

        if(timer.frames() >= 10000) {
            List<Double> times = timer.get();
            times.sort(Double::compare);
            double median = times.get(times.size()/2);
            double p25 = times.get((int) Math.ceil(times.size()*0.25));
            double p75 = times.get((int) Math.ceil(times.size()*0.75));
            double min = times.get(0);
            double max = times.get(times.size()-1);
            double average = times.stream().mapToDouble(d -> d).average().orElse(0);
            client.inGameHud.getChatHud().addMessage(Text.literal(String.format("Stats over %d frames: %.3f / %.3f / %.3f min/avg/max %.3f / %.3f / %.3f p25/med/p75", timer.frames(), min, average, max, p25, median, p75)));
            timer.reset();
        }

        if(Main.IS_DEV) GL43.glPopDebugGroup();

//        RenderSystem.enableBlend();
//        RenderSystem.defaultBlendFunc();
//        for (Box chunk : visibleChunks) {
//            DebugRenderer.drawBox(chunk.offset(cam.multiply(-1)), 0.5f, 1.0f, 0.5f, 0.5f);
//        }
//        for (Box chunk : hiddenChunks) {
//            DebugRenderer.drawBox(chunk.offset(cam.multiply(-1)), 1.0f, 0.5f, 0.5f, 0.5f);
//        }
    }

    private float getCloudsHeight(DimensionEffects effects) {
        if(SodiumExtraCompat.IS_LOADED) {
            if (effects.getSkyType() == DimensionEffects.SkyType.NORMAL) {
                return SodiumExtraCompat.getCloudsHeight();
            }
        }

        return effects.getCloudsHeight();
    }

    private boolean isFancyMode() {
        return client.options.getCloudRenderModeValue() == CloudRenderMode.FANCY;
    }

    public void close() {
        if(cloudShader != null) cloudShader.close();
        if(cloudGenerator != null) cloudGenerator.close();
    }
}
